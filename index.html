<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GAMERYT Tetris</title>
    <meta name="theme-color" content="#4f46e5"/>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --background-light: #f3f4f6;
            --text-light: #1f2937;
            --surface-light: #ffffff;
            --primary-light: #4f46e5;
            --primary-hover-light: #4338ca;

            --background-dark: #111827;
            --text-dark: #f9fafb;
            --surface-dark: #1f2937;
            --primary-dark: #6366f1;
            --primary-hover-dark: #4f46e5;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-light);
            color: var(--text-light);
            transition: background-color 0.3s, color 0.3s;
        }

        .dark body {
            background-color: var(--background-dark);
            color: var(--text-dark);
        }
        
        .surface {
            background-color: var(--surface-light);
            transition: background-color 0.3s;
        }
        
        .dark .surface {
            background-color: var(--surface-dark);
        }
        
        .btn-primary {
            background-color: var(--primary-light);
            color: white;
            border-radius: 20px;
            transition: background-color 0.2s;
        }
        
        .btn-primary:hover {
            background-color: var(--primary-hover-light);
        }

        .dark .btn-primary {
            background-color: var(--primary-dark);
        }
        
        .dark .btn-primary:hover {
            background-color: var(--primary-hover-dark);
        }

        .nav-link {
            transition: color 0.2s;
        }
        
        .nav-link.active {
            color: var(--primary-light);
            font-weight: 600;
        }

        .dark .nav-link.active {
            color: var(--primary-dark);
        }

        #tetris-canvas, #next-piece-canvas {
            border: 2px solid #e5e7eb;
        }
        .dark #tetris-canvas, .dark #next-piece-canvas {
            border-color: #374151;
        }

        /* Custom Toggle Switch */
        .toggle-switch-label {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }
        .toggle-switch-label input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-switch-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 28px;
        }
        .toggle-switch-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-switch-slider {
            background-color: var(--primary-light);
        }
        .dark input:checked + .toggle-switch-slider {
            background-color: var(--primary-dark);
        }
        input:checked + .toggle-switch-slider:before {
            transform: translateX(22px);
        }

        /* Custom Toast */
        #custom-toast {
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 1rem 1.5rem;
            border-radius: 20px;
            color: white;
            font-weight: 500;
            z-index: 100;
            transition: bottom 0.5s ease-in-out;
        }
        
        /* Custom Modal Styles */
        .custom-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .custom-modal-content {
            padding: 2rem;
            border-radius: 1rem;
            min-width: 300px;
            max-width: 90%;
        }
    </style>
</head>
<body class="antialiased">

    <!-- Offline Banner -->
    <div id="offline-banner" class="hidden bg-yellow-500 text-white text-center p-2 fixed top-0 w-full z-50">
        You're offline. You can still play Tetris!
    </div>

    <!-- Main Container -->
    <div id="app" class="min-h-screen flex flex-col">

        <!-- Top Bar -->
        <header class="surface shadow-md sticky top-0 z-40">
            <nav class="container mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex items-center justify-between h-16">
                    <div class="flex items-center space-x-3">
                        <div id="logo-icon"><svg class="h-8 w-8 text-purple-600" viewBox="0 0 24 24" fill="currentColor"><path d="M9 3H15V9H21V15H15V21H9V15H3V9H9V3Z"/></svg></div>
                        <span class="text-xl font-bold" data-lang-key="title">GAMERYT Tetris</span>
                    </div>
                    <div class="hidden md:flex items-center space-x-8">
                        <a href="#" class="nav-link active" data-tab="game" data-lang-key="nav_game">Game</a>
                        <a href="#" class="nav-link" data-tab="editor" data-lang-key="nav_editor">Editor</a>
                        <a href="#" class="nav-link" data-tab="settings" data-lang-key="nav_settings">Settings</a>
                    </div>
                    <div class="flex items-center space-x-4">
                        <button id="dark-mode-toggle" class="p-2 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500">
                            <svg id="sun-icon" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"/></svg>
                            <svg id="moon-icon" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"/></svg>
                        </button>
                        <div class="relative hidden md:block">
                            <select id="language-selector" class="pl-3 pr-8 py-2 rounded-full appearance-none focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 surface">
                                <option value="en">English</option><option value="es">Español</option><option value="fr">Français</option><option value="de">Deutsch</option><option value="ru">Русский</option><option value="pt">Português</option><option value="zh">中文</option><option value="ja">日本語</option><option value="ko">한국어</option>
                            </select>
                        </div>
                        <div class="md:hidden">
                            <button id="mobile-menu-button" class="p-2 rounded-md focus:outline-none focus:ring-2 focus:ring-inset focus:ring-purple-500">
                                <svg class="h-6 w-6" stroke="currentColor" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                            </button>
                        </div>
                    </div>
                </div>
                <div id="mobile-menu" class="hidden md:hidden pb-4">
                    <div class="px-2 pt-2 pb-3 space-y-1 sm:px-3">
                        <a href="#" class="nav-link active block px-3 py-2 rounded-md text-base font-medium" data-tab="game" data-lang-key="nav_game">Game</a>
                        <a href="#" class="nav-link block px-3 py-2 rounded-md text-base font-medium" data-tab="editor" data-lang-key="nav_editor">Editor</a>
                        <a href="#" class="nav-link block px-3 py-2 rounded-md text-base font-medium" data-tab="settings" data-lang-key="nav_settings">Settings</a>
                    </div>
                    <div class="pt-4 pb-3 border-t border-gray-700">
                        <div class="flex items-center px-5">
                             <select id="language-selector-mobile" class="w-full pl-3 pr-8 py-2 rounded-full appearance-none focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 surface">
                                <option value="en">English</option><option value="es">Español</option><option value="fr">Français</option><option value="de">Deutsch</option><option value="ru">Русский</option><option value="pt">Português</option><option value="zh">中文</option><option value="ja">日本語</option><option value="ko">한국어</option>
                            </select>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <!-- Main Content -->
        <main class="flex-grow container mx-auto p-4 sm:p-6 lg:p-8">
            <!-- Game Tab -->
            <div id="game-tab" class="tab-content">
                <div id="game-layout-container" class="flex flex-col lg:flex-row gap-8 items-start justify-center">
                    <div id="game-canvas-container" class="flex flex-col items-center">
                       <canvas id="tetris-canvas" width="300" height="600"></canvas>
                        <div id="on-screen-controls" class="mt-4 grid grid-cols-4 gap-2 w-full max-w-sm">
                            <button id="move-left-btn" class="btn-primary p-4 flex justify-center items-center"><svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg></button>
                            <button id="move-right-btn" class="btn-primary p-4 flex justify-center items-center"><svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg></button>
                            <button id="rotate-btn" class="btn-primary p-4 flex justify-center items-center"><svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20h5v-5M20 4h-5v5"/></svg></button>
                            <button id="fast-down-btn" class="btn-primary p-4 flex justify-center items-center"><svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 13l-7 7-7-7m14-8l-7 7-7-7"/></svg></button>
                        </div>
                    </div>
                    <div class="flex flex-col space-y-4 w-full lg:w-64">
                        <div id="game-info-container" class="surface p-6 rounded-lg shadow-lg">
                            <h2 class="text-2xl font-bold mb-4" data-lang-key="score">Score</h2><p id="score" class="text-4xl font-mono mb-6">0</p>
                            <h2 class="text-2xl font-bold mb-4" data-lang-key="placed">Placed</h2><p id="placed" class="text-4xl font-mono">0</p>
                            <h2 class="text-2xl font-bold mb-4" data-lang-key="lines">Lines</h2><p id="lines-count" class="text-4xl font-mono">0 / 10</p>
                        </div>
                        <div id="next-piece-container" class="surface p-6 rounded-lg shadow-lg">
                             <h2 class="text-2xl font-bold mb-4" data-lang-key="next">Next</h2>
                             <div class="flex justify-center items-center"><canvas id="next-piece-canvas" width="120" height="120"></canvas></div>
                        </div>
                        <div id="wins-overs-container" class="surface p-6 rounded-lg shadow-lg">
                            <div class="flex justify-between items-center">
                                <div><h3 class="font-bold" data-lang-key="wins">Wins</h3><p id="wins-count" class="text-2xl font-mono">0</p></div>
                                <div><h3 class="font-bold" data-lang-key="overs">Overs</h3><p id="overs-count" class="text-2xl font-mono">0</p></div>
                            </div>
                        </div>
                        <button id="try-again-btn" class="btn-primary w-full py-3 font-semibold" data-lang-key="try_again">Try Again</button>
                    </div>
                </div>
            </div>

            <!-- Editor Tab -->
            <div id="editor-tab" class="tab-content hidden">
                <div class="text-center">
                    <h2 class="text-3xl font-bold mb-2" data-lang-key="editor_title">Block Editor</h2>
                    <p class="mb-6" data-lang-key="editor_desc_full">Edit default blocks, or create, save, and delete your own custom blocks!</p>
                    <div class="flex flex-col xl:flex-row items-start justify-center gap-8">
                        <div class="surface p-6 rounded-lg shadow-lg w-full xl:w-auto">
                            <h3 class="text-xl font-semibold mb-4" data-lang-key="editor_select">Select or Create Block</h3>
                            <div id="block-selection-list" class="grid grid-cols-4 sm:grid-cols-5 md:grid-cols-7 gap-2"></div>
                            <button id="add-new-block-btn" class="mt-4 w-full btn-primary py-2 font-semibold flex items-center justify-center gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                                <span data-lang-key="editor_add_new">Add New</span>
                            </button>
                        </div>
                        <div class="flex flex-col md:flex-row items-center justify-center gap-8">
                            <div class="surface p-6 rounded-lg shadow-lg">
                                <h3 class="text-xl font-semibold mb-4" data-lang-key="editor_color">Block Color</h3>
                                <input type="color" id="editor-color-picker" value="#4f46e5" class="w-24 h-12 rounded-lg cursor-pointer">
                            </div>
                            <div class="surface p-4 rounded-lg shadow-lg">
                                <div id="editor-grid" class="grid grid-cols-4 gap-1"></div>
                            </div>
                        </div>
                    </div>
                    <button id="save-block-btn" class="mt-8 btn-primary px-8 py-3 font-semibold" data-lang-key="editor_save">Save Block</button>
                </div>
            </div>

            <!-- Settings Tab -->
            <div id="settings-tab" class="tab-content hidden">
                <div class="max-w-2xl mx-auto space-y-8">
                    <div class="surface p-6 rounded-lg shadow-lg">
                        <h3 class="text-2xl font-bold border-b pb-2 mb-4" data-lang-key="settings_gameplay">Gameplay</h3>
                        <div class="flex justify-between items-center mb-4">
                            <span data-lang-key="settings_speed">Game Speed</span>
                            <select id="game-speed" class="p-2 rounded-lg surface border border-gray-300 dark:border-gray-600">
                                <option value="1" data-lang-key="speed_default">Default</option><option value="0.8">1 (Faster)</option><option value="0.6">2 (Very Fast)</option><option value="0.4">3 (Expert)</option><option value="0.2">4 (Insane)</option>
                            </select>
                        </div>
                        <div class="flex justify-between items-center">
                            <span data-lang-key="settings_sfx">Sound Effects</span>
                            <label for="sfx-toggle" class="flex items-center cursor-pointer">
                                <div class="relative"><input type="checkbox" id="sfx-toggle" class="sr-only"><div class="block bg-gray-600 w-14 h-8 rounded-full"></div><div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition"></div></div>
                                <div class="ml-3 font-medium" id="sfx-status" data-lang-key="sfx_off">Off</div>
                            </label>
                        </div>
                    </div>
                     <div class="surface p-6 rounded-lg shadow-lg">
                        <h3 class="text-2xl font-bold border-b pb-2 mb-4" data-lang-key="settings_layout">Layout & UI</h3>
                        <p class="text-sm mb-4" data-lang-key="settings_layout_desc">Toggle visibility of game screen elements.</p>
                        <div class="space-y-3">
                            <div class="flex justify-between items-center"><span data-lang-key="score">Score/Placed Panel</span><label class="toggle-switch-label"><input type="checkbox" id="toggle-score"><span class="toggle-switch-slider"></span></label></div>
                            <div class="flex justify-between items-center"><span data-lang-key="wins">Wins/Overs Panel</span><label class="toggle-switch-label"><input type="checkbox" id="toggle-wins-overs"><span class="toggle-switch-slider"></span></label></div>
                            <div class="flex justify-between items-center"><span data-lang-key="controls">On-Screen Controls</span><label class="toggle-switch-label"><input type="checkbox" id="toggle-controls"><span class="toggle-switch-slider"></span></label></div>
                        </div>
                    </div>
                    <div class="surface p-6 rounded-lg shadow-lg">
                        <h3 class="text-2xl font-bold border-b pb-2 mb-4" data-lang-key="settings_shortcuts">Keyboard Shortcuts</h3>
                        <ul class="space-y-2">
                            <li><kbd class="font-mono p-1 rounded bg-gray-200 dark:bg-gray-700">←</kbd> / <kbd class="font-mono p-1 rounded bg-gray-200 dark:bg-gray-700">→</kbd> - <span data-lang-key="shortcut_move">Move piece</span></li>
                            <li><kbd class="font-mono p-1 rounded bg-gray-200 dark:bg-gray-700">↑</kbd> - <span data-lang-key="shortcut_rotate">Rotate piece</span></li>
                            <li><kbd class="font-mono p-1 rounded bg-gray-200 dark:bg-gray-700">↓</kbd> - <span data-lang-key="shortcut_soft_drop">Soft drop</span></li>
                            <li><kbd class="font-mono p-1 rounded bg-gray-200 dark:bg-gray-700">Space</kbd> - <span data-lang-key="shortcut_hard_drop">Hard drop</span></li>
                        </ul>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div id="custom-toast"></div>
    
    <div id="confirm-modal" class="custom-modal-overlay hidden"><div class="custom-modal-content surface shadow-xl"><h3 id="confirm-title" class="text-xl font-bold mb-4">Confirm Action</h3><p id="confirm-message" class="mb-6">Are you sure?</p><div class="flex justify-end space-x-4"><button id="confirm-cancel-btn" class="py-2 px-4 rounded-2xl bg-gray-300 dark:bg-gray-600" data-lang-key="cancel">Cancel</button><button id="confirm-ok-btn" class="btn-primary py-2 px-4">OK</button></div></div></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Translations ---
        const translations = {
            en: {
                title: "GAMERYT Tetris", nav_game: "Game", nav_editor: "Editor", nav_settings: "Settings",
                score: "Score", placed: "Placed", lines: "Lines", try_again: "Try Again", next: "Next", wins: "Wins", overs: "Overs", controls: "Controls",
                editor_title: "Block Editor", editor_desc_full: "Edit default blocks, or create, save, and delete your own custom blocks!", editor_select: "Select or Create Block", editor_color: "Block Color", editor_save: "Save Block", editor_add_new: "Add New",
                settings_gameplay: "Gameplay", settings_layout: "Layout & UI", settings_layout_desc: "Toggle visibility of game screen elements.",
                settings_speed: "Game Speed", speed_default: "Default", settings_sfx: "Sound Effects", sfx_off: "Off", sfx_on: "On",
                settings_shortcuts: "Keyboard Shortcuts", shortcut_move: "Move piece", shortcut_rotate: "Rotate piece", shortcut_soft_drop: "Soft drop", shortcut_hard_drop: "Hard drop",
                credits: "Made by GAMERYTDeveloper",
                close: "Close", cancel: "Cancel", game_over: "Game Over!", line_cleared: "Line Cleared!", you_win: "You Win!",
                block_saved: "Block saved!", block_created: "New block created!", block_deleted: "Block deleted!", confirm_delete_block: "Are you sure you want to delete this custom block?",
            },
            es: {
                title: "GAMERYT Tetris", nav_game: "Juego", nav_editor: "Editor", nav_settings: "Ajustes",
                score: "Puntuación", placed: "Colocadas", lines: "Líneas", try_again: "Intentar de Nuevo", next: "Siguiente", wins: "Victorias", overs: "Derrotas", controls: "Controles",
                editor_title: "Editor de Bloques", editor_desc_full: "¡Edita bloques predeterminados o crea, guarda y elimina tus propios bloques personalizados!", editor_select: "Seleccionar o Crear Bloque", editor_color: "Color del Bloque", editor_save: "Guardar Bloque", editor_add_new: "Añadir Nuevo",
                settings_gameplay: "Jugabilidad", settings_layout: "Diseño e Interfaz", settings_layout_desc: "Alternar la visibilidad de los elementos de la pantalla de juego.",
                settings_speed: "Velocidad del Juego", speed_default: "Predeterminada", settings_sfx: "Efectos de Sonido", sfx_off: "Apagado", sfx_on: "Encendido",
                credits: "Hecho por GAMERYTDeveloper",
                close: "Cerrar", cancel: "Cancelar", game_over: "¡Juego Terminado!", line_cleared: "¡Línea Eliminada!", you_win: "¡Ganaste!",
                block_saved: "¡Bloque guardado!", block_created: "¡Nuevo bloque creado!", block_deleted: "¡Bloque eliminado!", confirm_delete_block: "¿Estás seguro de que quieres eliminar este bloque personalizado?",
            },
            fr: {
                title: "GAMERYT Tetris", nav_game: "Jeu", nav_editor: "Éditeur", nav_settings: "Paramètres",
                score: "Score", placed: "Placées", lines: "Lignes", try_again: "Réessayer", next: "Suivant", wins: "Victoires", overs: "Défaites", controls: "Contrôles",
                editor_title: "Éditeur de Blocs", editor_desc_full: "Modifiez les blocs par défaut, ou créez, sauvegardez et supprimez vos propres blocs personnalisés!", editor_select: "Sélectionner ou Créer", editor_color: "Couleur du Bloc", editor_save: "Sauvegarder", editor_add_new: "Ajouter Nouveau",
                settings_gameplay: "Jeu", settings_layout: "Disposition et IU", settings_layout_desc: "Activez ou désactivez la visibilité des éléments de l'écran de jeu.",
                settings_speed: "Vitesse du jeu", speed_default: "Défaut", settings_sfx: "Effets sonores", sfx_off: "Désactivé", sfx_on: "Activé",
                settings_shortcuts: "Raccourcis clavier", shortcut_move: "Déplacer la pièce", shortcut_rotate: "Faire pivoter la pièce", shortcut_soft_drop: "Chute douce", shortcut_hard_drop: "Chute brutale",
                close: "Fermer", cancel: "Annuler", game_over: "Jeu terminé!", line_cleared: "Ligne effacée!", you_win: "Vous avez gagné!",
                block_saved: "Bloc sauvegardé!", block_created: "Nouveau bloc créé!", block_deleted: "Bloc supprimé!", confirm_delete_block: "Êtes-vous sûr de vouloir supprimer ce bloc personnalisé?",
            },
            de: {
                title: "GAMERYT Tetris", nav_game: "Spiel", nav_editor: "Editor", nav_settings: "Einstellungen",
                score: "Punktzahl", placed: "Platziert", lines: "Linien", try_again: "Erneut versuchen", next: "Nächster", wins: "Siege", overs: "Niederlagen", controls: "Steuerung",
                editor_title: "Block-Editor", editor_desc_full: "Bearbeiten Sie Standardblöcke oder erstellen, speichern und löschen Sie Ihre eigenen benutzerdefinierten Blöcke!", editor_select: "Block auswählen oder erstellen", editor_color: "Blockfarbe", editor_save: "Block speichern", editor_add_new: "Neu hinzufügen",
                settings_gameplay: "Spielablauf", settings_layout: "Layout & UI", settings_layout_desc: "Sichtbarkeit von Spielbildelementen umschalten.",
                settings_speed: "Spielgeschwindigkeit", speed_default: "Standard", settings_sfx: "Soundeffekte", sfx_off: "Aus", sfx_on: "An",
                settings_shortcuts: "Tastatürkürzel", shortcut_move: "Stein bewegen", shortcut_rotate: "Stein drehen", shortcut_soft_drop: "Weicher Fall", shortcut_hard_drop: "Harter Fall",
                close: "Schließen", cancel: "Abbrechen", game_over: "Spiel vorbei!", line_cleared: "Reihe geschafft!", you_win: "Du hast gewonnen!",
                block_saved: "Block gespeichert!", block_created: "Neuer Block erstellt!", block_deleted: "Block gelöscht!", confirm_delete_block: "Sind Sie sicher, dass Sie diesen benutzerdefinierten Block löschen möchten?",
            },
            ru: {
                title: "ГАМЕРИТ Тетрис", nav_game: "Игра", nav_editor: "Редактор", nav_settings: "Настройки",
                score: "Счет", placed: "Размещено", lines: "Линии", try_again: "Попробовать снова", next: "Следующий", wins: "Победы", overs: "Поражения", controls: "Управление",
                editor_title: "Редактор блоков", editor_desc_full: "Редактируйте стандартные блоки или создавайте, сохраняйте и удаляйте свои собственные блоки!", editor_select: "Выбрать или создать блок", editor_color: "Цвет блока", editor_save: "Сохранить блок", editor_add_new: "Добавить новый",
                settings_gameplay: "Игровой процесс", settings_layout: "Макет и интерфейс", settings_layout_desc: "Переключить видимость элементов игрового экрана.",
                settings_speed: "Скорость игры", speed_default: "По умолчанию", settings_sfx: "Звуковые эффекты", sfx_off: "Выкл", sfx_on: "Вкл",
                settings_shortcuts: "Горячие клавиши", shortcut_move: "Переместить фигуру", shortcut_rotate: "Повернуть фигуру", shortcut_soft_drop: "Мягкое падение", shortcut_hard_drop: "Жесткое падение",
                close: "Закрыть", cancel: "Отмена", game_over: "Игра окончена!", line_cleared: "Линия очищена!", you_win: "Вы победили!",
                block_saved: "Блок сохранен!", block_created: "Новый блок создан!", block_deleted: "Блок удален!", confirm_delete_block: "Вы уверены, что хотите удалить этот пользовательский блок?",
            },
            pt: {
                title: "GAMERYT Tetris", nav_game: "Jogo", nav_editor: "Editor", nav_settings: "Configurações",
                score: "Pontuação", placed: "Colocadas", lines: "Linhas", try_again: "Tentar Novamente", next: "Próximo", wins: "Vitórias", overs: "Derrotas", controls: "Controles",
                editor_title: "Editor de Blocos", editor_desc_full: "Edite blocos padrão ou crie, salve e exclua seus próprios blocos personalizados!", editor_select: "Selecionar ou Criar Bloco", editor_color: "Cor do Bloco", editor_save: "Salvar Bloco", editor_add_new: "Adicionar Novo",
                settings_gameplay: "Jogabilidade", settings_layout: "Layout e IU", settings_layout_desc: "Alternar a visibilidade dos elementos da tela do jogo.",
                settings_speed: "Velocidade do Jogo", speed_default: "Padrão", settings_sfx: "Efeitos Sonoros", sfx_off: "Desligado", sfx_on: "Ligado",
                settings_shortcuts: "Atalhos de Teclado", shortcut_move: "Mover peça", shortcut_rotate: "Girar peça", shortcut_soft_drop: "Queda suave", shortcut_hard_drop: "Queda rápida",
                close: "Fechar", cancel: "Cancelar", game_over: "Fim de Jogo!", line_cleared: "Linha Eliminada!", you_win: "Você venceu!",
                block_saved: "Bloco salvo!", block_created: "Novo bloco criado!", block_deleted: "Bloco excluído!", confirm_delete_block: "Tem certeza de que deseja excluir este bloco personalizado?",
            },
            zh: {
                title: "GAMERYT 俄罗斯方块", nav_game: "游戏", nav_editor: "编辑器", nav_settings: "设置",
                score: "分数", placed: "已放置", lines: "行数", try_again: "再试一次", next: "下一个", wins: "胜利", overs: "失败", controls: "控件",
                editor_title: "块编辑器", editor_desc_full: "编辑默认块，或创建、保存和删除您自己的自定义块！", editor_select: "选择或创建块", editor_color: "块颜色", editor_save: "保存块", editor_add_new: "添加新的",
                settings_gameplay: "游戏玩法", settings_layout: "布局和界面", settings_layout_desc: "切换游戏屏幕元素的可见性。",
                settings_speed: "游戏速度", speed_default: "默认", settings_sfx: "音效", sfx_off: "关", sfx_on: "开",
                settings_shortcuts: "键盘快捷键", shortcut_move: "移动方块", shortcut_rotate: "旋转方块", shortcut_soft_drop: "软降", shortcut_hard_drop: "硬降",
                close: "关闭", cancel: "取消", game_over: "游戏结束！", line_cleared: "消除了一行！", you_win: "你赢了！",
                block_saved: "块已保存！", block_created: "新块已创建！", block_deleted: "块已删除！", confirm_delete_block: "您确定要删除此自定义块吗？",
            },
            ja: {
                title: "GAMERYT テトリス", nav_game: "ゲーム", nav_editor: "エディタ", nav_settings: "設定",
                score: "スコア", placed: "配置済み", lines: "ライン", try_again: "もう一度", next: "次", wins: "勝利", overs: "敗北", controls: "操作",
                editor_title: "ブロックエディタ", editor_desc_full: "デフォルトのブロックを編集するか、独自のカスタムブロックを作成、保存、削除します！", editor_select: "ブロックを選択または作成", editor_color: "ブロックの色", editor_save: "ブロックを保存", editor_add_new: "新規追加",
                settings_gameplay: "ゲームプレイ", settings_layout: "レイアウトとUI", settings_layout_desc: "ゲーム画面要素の表示/非表示を切り替えます。",
                settings_speed: "ゲーム速度", speed_default: "デフォルト", settings_sfx: "効果音", sfx_off: "オフ", sfx_on: "オン",
                settings_shortcuts: "キーボードショートカット", shortcut_move: "ピースを移動", shortcut_rotate: "ピースを回転", shortcut_soft_drop: "ソフトドロップ", shortcut_hard_drop: "ハードドロップ",
                close: "閉じる", cancel: "キャンセル", game_over: "ゲームオーバー！", line_cleared: "ラインを消去しました！", you_win: "あなたの勝ちです！",
                block_saved: "ブロックが保存されました！", block_created: "新しいブロックが作成されました！", block_deleted: "ブロックが削除されました！", confirm_delete_block: "このカスタムブロックを本当に削除しますか？",
            },
            ko: {
                title: "GAMERYT 테트리스", nav_game: "게임", nav_editor: "에디터", nav_settings: "설정",
                score: "점수", placed: "놓음", lines: "줄", try_again: "다시 시도", next: "다음", wins: "승리", overs: "패배", controls: "컨트롤",
                editor_title: "블록 에디터", editor_desc_full: "기본 블록을 편집하거나 자신만의 맞춤 블록을 만들고, 저장하고, 삭제하세요!", editor_select: "블록 선택 또는 생성", editor_color: "블록 색상", editor_save: "블록 저장", editor_add_new: "새로 추가",
                settings_gameplay: "게임 플레이", settings_layout: "레이아웃 및 UI", settings_layout_desc: "게임 화면 요소의 가시성을 전환합니다.",
                settings_speed: "게임 속도", speed_default: "기본값", settings_sfx: "음향 효과", sfx_off: "끄기", sfx_on: "켜기",
                settings_shortcuts: "키보드 단축키", shortcut_move: "조각 이동", shortcut_rotate: "조각 회전", shortcut_soft_drop: "소프트 드롭", shortcut_hard_drop: "하드 드롭",
                close: "닫기", cancel: "취소", game_over: "게임 종료!", line_cleared: "줄이 지워졌습니다!", you_win: "승리했습니다!",
                block_saved: "블록이 저장되었습니다!", block_created: "새 블록이 생성되었습니다!", block_deleted: "블록이 삭제되었습니다!", confirm_delete_block: "이 맞춤 블록을 정말로 삭제하시겠습니까?",
            },
        };

        // --- App State & Config ---
        let isSfxOn = false;
        let dropInterval = 1000;
        let gameSettings = {};
        const defaultPieces = Object.freeze([ [[1, 1], [1, 1]], [[0, 2, 0], [2, 2, 2]], [[0, 3, 3], [3, 3, 0]], [[4, 4, 0], [0, 4, 4]], [[5, 5, 5, 5]], [[0, 0, 6], [6, 6, 6]], [[7, 0, 0], [7, 7, 7]] ]);
        let customPieces = [];
        let allPieces = [];
        let wins = 0, overs = 0;

        // --- Sound Effects ---
        const synth = new Tone.Synth().toDestination();
        const sounds = { move:()=>synth.triggerAttackRelease("C2","8n"), rotate:()=>synth.triggerAttackRelease("E2","8n"), drop:()=>synth.triggerAttackRelease("G2","8n"), clear:()=>synth.triggerAttackRelease("C4","8n"), gameOver:()=>synth.triggerAttackRelease("C3","2n"), win:()=>synth.triggerAttackRelease("G4","2n"), click:()=>synth.triggerAttackRelease("C5","16n") };
        function playSound(sound) { if (isSfxOn) { Tone.start().then(() => sounds[sound]()); } }

        // --- Settings & Local Storage ---
        const settingsMap = {
            darkMode: { el: document.documentElement, class: 'dark', type: 'class' },
            showScore: { el: document.getElementById('game-info-container'), class: 'hidden', type: 'visibility', invert: true },
            showWinsOvers: { el: document.getElementById('wins-overs-container'), class: 'hidden', type: 'visibility', invert: true },
            showControls: { el: document.getElementById('on-screen-controls'), class: 'hidden', type: 'visibility', invert: true },
            sfx: { el: document.getElementById('sfx-toggle'), type: 'sfx' },
            speed: { el: document.getElementById('game-speed'), type: 'speed' },
        };
        function saveSettings() { localStorage.setItem('gamerytTetrisSettings', JSON.stringify(gameSettings)); }
        function applySetting(key, value) {
            const config = settingsMap[key]; if (!config) return;
            gameSettings[key] = value;
            switch(config.type) {
                case 'class':
                    config.el.classList.toggle(config.class, value);
                    if (key === 'darkMode') { document.getElementById('sun-icon').classList.toggle('hidden', value); document.getElementById('moon-icon').classList.toggle('hidden', !value); }
                    break;
                case 'visibility':
                    const isVisible = config.invert ? value : !value;
                    config.el.classList.toggle(config.class, !isVisible);
                    const toggleEl = document.getElementById(`toggle-${key.replace('show', '').toLowerCase()}`);
                    if (toggleEl) toggleEl.checked = value;
                    break;
                case 'sfx':
                    isSfxOn = value; config.el.checked = value;
                    const lang = document.getElementById('language-selector').value;
                    const sfxStatus = document.getElementById('sfx-status');
                    sfxStatus.textContent = isSfxOn ? translations[lang].sfx_on : translations[lang].sfx_off;
                    sfxStatus.setAttribute('data-lang-key', isSfxOn ? 'sfx_on' : 'sfx_off');
                    break;
                case 'speed':
                    dropInterval = parseFloat(value) * 1000; config.el.value = value;
                    if (gameRunning) { clearInterval(gameLoop); gameLoop = setInterval(playerDrop, dropInterval); }
                    break;
            }
        }
        function loadSettings() {
            const saved = JSON.parse(localStorage.getItem('gamerytTetrisSettings')) || {};
            const defaults = { darkMode: false, showScore: true, showWinsOvers: true, showControls: true, sfx: false, speed: '1' };
            gameSettings = { ...defaults, ...saved };
            Object.keys(gameSettings).forEach(key => applySetting(key, gameSettings[key]));
        }

        function saveGameStats() { localStorage.setItem('gamerytGameStats', JSON.stringify({ wins, overs })); }
        function loadGameStats() {
            const stats = JSON.parse(localStorage.getItem('gamerytGameStats')) || { wins: 0, overs: 0 };
            wins = stats.wins;
            overs = stats.overs;
            document.getElementById('wins-count').innerText = wins;
            document.getElementById('overs-count').innerText = overs;
        }

        // --- Custom Pieces Storage ---
        function loadCustomPieces() {
            customPieces = JSON.parse(localStorage.getItem('gamerytCustomPieces')) || [];
            updateAllPieces();
        }
        function saveCustomPieces() {
            localStorage.setItem('gamerytCustomPieces', JSON.stringify(customPieces));
            updateAllPieces();
        }
        function updateAllPieces() {
            allPieces = [...defaultPieces, ...customPieces];
        }

        // --- UI Functions ---
        function updateLanguage(lang) {
            const langPack = translations[lang] || translations.en;
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.getAttribute('data-lang-key');
                if (langPack[key]) el.textContent = langPack[key];
            });
            document.getElementById('language-selector').value = lang;
            document.getElementById('language-selector-mobile').value = lang;
        }
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.add('hidden'));
            document.getElementById(`${tabId}-tab`).classList.remove('hidden');
            document.querySelectorAll('.nav-link').forEach(link => link.classList.toggle('active', link.dataset.tab === tabId));
            document.getElementById('mobile-menu').classList.add('hidden');
        }
        const toastEl = document.getElementById('custom-toast');
        function showToast(messageKey, type = 'info') {
            const lang = document.getElementById('language-selector').value;
            const translatedMessage = translations[lang][messageKey] || messageKey;
            toastEl.textContent = translatedMessage;
            toastEl.className = 'fixed bottom-[-100px] left-1/2 -translate-x-1/2 p-4 rounded-2xl text-white font-medium z-[100] transition-all duration-500';
            if (type === 'success') toastEl.classList.add('bg-green-600');
            else if (type === 'error') toastEl.classList.add('bg-red-600');
            else toastEl.classList.add('bg-gray-800');
            toastEl.style.bottom = '20px';
            setTimeout(() => { toastEl.style.bottom = '-100px'; }, 3000);
        }
        const confirmModal = document.getElementById('confirm-modal');
        function showConfirm(title, messageKey, onOk) {
            const lang = document.getElementById('language-selector').value;
            document.getElementById('confirm-title').textContent = title;
            document.getElementById('confirm-message').textContent = translations[lang][messageKey] || messageKey;
            confirmModal.classList.remove('hidden');
            const okBtn = document.getElementById('confirm-ok-btn');
            const cancelBtn = document.getElementById('confirm-cancel-btn');
            const okHandler = () => { onOk(); hide(); };
            const cancelHandler = () => hide();
            function hide() {
                confirmModal.classList.add('hidden');
                okBtn.removeEventListener('click', okHandler);
                cancelBtn.removeEventListener('click', cancelHandler);
            }
            okBtn.addEventListener('click', okHandler);
            cancelBtn.addEventListener('click', cancelHandler);
        }

        // --- Tetris Game Logic ---
        const canvas = document.getElementById('tetris-canvas'), context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-piece-canvas'), nextContext = nextCanvas.getContext('2d');
        const COLS = 10, ROWS = 20, BLOCK_SIZE = 30, WIN_CONDITION_LINES = 10;
        context.canvas.width = COLS * BLOCK_SIZE; context.canvas.height = ROWS * BLOCK_SIZE;
        let board, player, nextPlayer, score, placedCount, totalLinesCleared, gameLoop, gameRunning;
        const colors = [ null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF', '#38D9FF', '#9E38FF', '#FF3838', '#38FFB8' ];

        function createPiece() {
            const typeIndex = allPieces.length * Math.random() | 0;
            const matrix = allPieces[typeIndex];
            return { pos: { x: (COLS / 2 | 0) - (matrix[0].length / 2 | 0), y: 0 }, matrix: matrix };
        }
        function playerReset() {
            player = nextPlayer || createPiece();
            nextPlayer = createPiece();
            if (collide(board, player)) {
                gameRunning = false; clearInterval(gameLoop); playSound('gameOver'); showToast('game_over', 'error');
                overs++;
                document.getElementById('overs-count').innerText = overs;
                saveGameStats();
            }
        }
        function collide(board, player) {
            const [m, o] = [player.matrix, player.pos];
            for (let y = 0; y < m.length; ++y) for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0 && (board[y + o.y] && board[y + o.y][x + o.x]) !== 0) return true;
            }
            return false;
        }
        function merge(board, player) { player.matrix.forEach((row, y) => row.forEach((value, x) => { if (value !== 0) board[y + player.pos.y][x + player.pos.x] = value; })); }
        
        function rotate(matrix) {
            const transposed = matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
            return transposed.map(row => row.reverse());
        }

        function playerRotate() {
            const originalPos = player.pos.x;
            const originalMatrix = player.matrix;
            player.matrix = rotate(player.matrix);
            let offset = 1;
            while (collide(board, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (Math.abs(offset) > player.matrix[0].length) {
                    player.matrix = originalMatrix; player.pos.x = originalPos; return;
                }
            }
            playSound('rotate');
        }
        function playerMove(dir) { player.pos.x += dir; if (collide(board, player)) player.pos.x -= dir; else playSound('move'); }
        function playerDrop() {
            if (!gameRunning) return;
            player.pos.y++;
            if (collide(board, player)) { player.pos.y--; merge(board, player); placedCount++; updateScore(0); playSound('drop'); playerReset(); sweep(); }
        }
        function hardDrop() {
            if (!gameRunning) return;
            while(!collide(board, player)) player.pos.y++;
            player.pos.y--; merge(board, player); placedCount++; updateScore(0); playSound('drop'); playerReset(); sweep();
        }
        function sweep() {
            let clearedLines = 0;
            outer: for (let y = board.length - 1; y > 0; --y) {
                for (let x = 0; x < board[y].length; ++x) if (board[y][x] === 0) continue outer;
                board.splice(y, 1); board.unshift(Array(COLS).fill(0));
                clearedLines++;
                ++y;
            }
            if (clearedLines > 0) {
                updateScore(clearedLines);
                totalLinesCleared += clearedLines;
                document.getElementById('lines-count').textContent = `${totalLinesCleared} / ${WIN_CONDITION_LINES}`;
                playSound('clear');
                showToast('line_cleared', 'success');

                if (totalLinesCleared >= WIN_CONDITION_LINES) {
                    gameRunning = false;
                    clearInterval(gameLoop);
                    wins++;
                    document.getElementById('wins-count').innerText = wins;
                    saveGameStats();
                    playSound('win');
                    showToast('you_win', 'success');
                }
            }
        }
        function updateScore(lines) {
            const points = [0, 100, 300, 500, 800];
            score += points[lines] || 0;
            document.getElementById('score').innerText = score;
            document.getElementById('placed').innerText = placedCount;
        }
        function drawMatrix(ctx, matrix, offset, scale) {
            ctx.save(); ctx.scale(scale, scale);
            matrix.forEach((row, y) => row.forEach((value, x) => {
                if (value !== 0) { ctx.fillStyle = colors[value % colors.length]; ctx.fillRect(x + offset.x, y + offset.y, 1, 1); }
            }));
            ctx.restore();
        }
        function draw() {
            const isDark = document.documentElement.classList.contains('dark');
            const bgColor = isDark ? '#111827' : '#f3f4f6';
            context.fillStyle = bgColor; context.fillRect(0, 0, canvas.width, canvas.height);
            drawMatrix(context, board, { x: 0, y: 0 }, BLOCK_SIZE);
            if(gameRunning && player) drawMatrix(context, player.matrix, player.pos, BLOCK_SIZE);
            nextContext.fillStyle = bgColor; nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            if (gameRunning && nextPlayer) {
                const matrix = nextPlayer.matrix; const scale = BLOCK_SIZE * 0.8;
                const offset = { x: (nextCanvas.width / scale - matrix[0].length) / 2, y: (nextCanvas.height / scale - matrix.length) / 2 };
                drawMatrix(nextContext, matrix, offset, scale);
            }
        }
        function startGame() {
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            score = 0; placedCount = 0; totalLinesCleared = 0;
            updateScore(0);
            document.getElementById('lines-count').textContent = `0 / ${WIN_CONDITION_LINES}`;
            nextPlayer = null; playerReset(); gameRunning = true;
            if(gameLoop) clearInterval(gameLoop); gameLoop = setInterval(playerDrop, dropInterval);
        }

        // --- Editor Logic ---
        const editorGrid = document.getElementById('editor-grid'), editorColorPicker = document.getElementById('editor-color-picker');
        const blockSelectionList = document.getElementById('block-selection-list');
        let editorCells = [], currentEditingIndex = null;

        function renderBlockSelection() {
            blockSelectionList.innerHTML = '';
            const combined = [...defaultPieces, ...customPieces];
            combined.forEach((p, index) => {
                const isCustom = index >= defaultPieces.length;
                const pieceColorValue = p.flat().find(v => v > 0) || 1;
                const pieceColor = colors[pieceColorValue % colors.length];
                const wrapper = document.createElement('div');
                wrapper.className = 'relative';
                const btn = document.createElement('button');
                btn.className = 'w-12 h-12 rounded-lg flex items-center justify-center border-2 border-transparent hover:border-purple-500';
                btn.style.backgroundColor = pieceColor + '33';
                const grid = document.createElement('div');
                grid.style.display = 'grid'; grid.style.gridTemplateColumns = `repeat(${p[0].length}, 1fr)`;
                p.forEach(row => row.forEach(val => {
                    const cell = document.createElement('div'); cell.className = 'w-2 h-2';
                    if (val !== 0) cell.style.backgroundColor = pieceColor;
                    grid.appendChild(cell);
                }));
                btn.appendChild(grid);
                btn.addEventListener('click', () => { playSound('click'); loadPieceIntoEditor(index); });
                wrapper.appendChild(btn);
                if (isCustom) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold hover:bg-red-700';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const customIndex = index - defaultPieces.length;
                        showConfirm('Delete Block', 'confirm_delete_block', () => {
                            customPieces.splice(customIndex, 1);
                            saveCustomPieces();
                            renderBlockSelection();
                            showToast('block_deleted', 'success');
                        });
                    });
                    wrapper.appendChild(deleteBtn);
                }
                blockSelectionList.appendChild(wrapper);
            });
        }
        function loadPieceIntoEditor(index) {
            currentEditingIndex = index;
            document.querySelectorAll('#block-selection-list button').forEach(b => b.classList.remove('border-purple-500', 'ring-2'));
            if (index !== 'new') {
                blockSelectionList.children[index]?.querySelector('button')?.classList.add('border-purple-500', 'ring-2');
            }
            const piece = (index === 'new' || index === null) ? [[0]] : allPieces[index];
            const pieceColorValue = piece.flat().find(v => v > 0) || 8;
            editorColorPicker.value = colors[pieceColorValue % colors.length];
            editorCells.forEach(cell => cell.style.backgroundColor = '');
            if (index === 'new' || index === null) return;
            const matrix = piece, startY = Math.floor((4 - matrix.length) / 2), startX = Math.floor((4 - matrix[0].length) / 2);
            for (let y = 0; y < matrix.length; y++) for (let x = 0; x < matrix[y].length; x++) {
                if (matrix[y][x] !== 0) {
                    const cellIndex = (startY + y) * 4 + (startX + x);
                    if(editorCells[cellIndex]) editorCells[cellIndex].style.backgroundColor = editorColorPicker.value;
                }
            }
        }
        document.getElementById('add-new-block-btn').addEventListener('click', () => { loadPieceIntoEditor('new'); });
        document.getElementById('save-block-btn').addEventListener('click', () => {
            if (currentEditingIndex === null) return;
            let newMatrix = [], hasDots = false, minX = 3, minY = 3, maxX = 0, maxY = 0;
            for (let y = 0; y < 4; y++) {
                const row = [];
                for (let x = 0; x < 4; x++) {
                    const hasColor = editorCells[y * 4 + x].style.backgroundColor !== '';
                    row.push(hasColor ? 1 : 0);
                    if (hasColor) { hasDots = true; minX = Math.min(minX, x); minY = Math.min(minY, y); maxX = Math.max(maxX, x); maxY = Math.max(maxY, y); }
                }
                newMatrix.push(row);
            }
            if (!hasDots) { showToast('Cannot save an empty block.', 'error'); return; }
            const cropped = newMatrix.slice(minY, maxY + 1).map(row => row.slice(minX, maxX + 1));
            const isCustom = currentEditingIndex >= defaultPieces.length;
            const isNew = currentEditingIndex === 'new';
            const colorIndex = isNew ? defaultPieces.length + customPieces.length + 1 : (isCustom ? defaultPieces.length + (currentEditingIndex - defaultPieces.length) + 1 : currentEditingIndex + 1);
            const finalMatrix = cropped.map(row => row.map(cell => cell === 1 ? (colorIndex % colors.length) || 8 : 0));
            
            if (isNew) {
                customPieces.push(finalMatrix);
                showToast('block_created', 'success');
            } else if (isCustom) {
                customPieces[currentEditingIndex - defaultPieces.length] = finalMatrix;
                showToast('block_saved', 'success');
            } else { // Editing a default piece, save as new custom piece
                customPieces.push(finalMatrix);
                showToast('block_created', 'success');
            }
            saveCustomPieces();
            renderBlockSelection();
            playSound('clear');
        });
        for (let i = 0; i < 16; i++) {
            const cell = document.createElement('div');
            cell.className = 'w-10 h-10 border border-gray-300 dark:border-gray-600 cursor-pointer transition-colors';
            cell.addEventListener('click', () => cell.style.backgroundColor ? cell.style.backgroundColor = '' : cell.style.backgroundColor = editorColorPicker.value);
            editorGrid.appendChild(cell);
            editorCells.push(cell);
        }

        // --- Event Listeners ---
        document.getElementById('dark-mode-toggle').addEventListener('click', () => { applySetting('darkMode', !document.documentElement.classList.contains('dark')); saveSettings(); });
        document.getElementById('language-selector').addEventListener('change', (e) => updateLanguage(e.target.value));
        document.getElementById('language-selector-mobile').addEventListener('change', (e) => updateLanguage(e.target.value));
        document.getElementById('mobile-menu-button').addEventListener('click', () => document.getElementById('mobile-menu').classList.toggle('hidden'));
        document.querySelectorAll('.nav-link').forEach(link => link.addEventListener('click', (e) => { e.preventDefault(); switchTab(e.currentTarget.dataset.tab); }));
        document.getElementById('try-again-btn').addEventListener('click', startGame);
        document.getElementById('sfx-toggle').addEventListener('change', (e) => { applySetting('sfx', e.target.checked); saveSettings(); });
        document.getElementById('game-speed').addEventListener('change', (e) => { applySetting('speed', e.target.value); saveSettings(); });
        document.getElementById('toggle-score').addEventListener('change', (e) => { applySetting('showScore', e.target.checked); saveSettings(); });
        document.getElementById('toggle-wins-overs').addEventListener('change', (e) => { applySetting('showWinsOvers', e.target.checked); saveSettings(); });
        document.getElementById('toggle-controls').addEventListener('change', (e) => { applySetting('showControls', e.target.checked); saveSettings(); });
        document.addEventListener('keydown', e => {
            if (!gameRunning) return;
            if (e.key === 'ArrowLeft') playerMove(-1); else if (e.key === 'ArrowRight') playerMove(1);
            else if (e.key === 'ArrowDown') playerDrop(); else if (e.key === 'ArrowUp') playerRotate();
            else if (e.key === ' ') { e.preventDefault(); hardDrop(); }
            draw();
        });
        document.getElementById('move-left-btn').addEventListener('click', () => { if(gameRunning) { playerMove(-1); draw(); } });
        document.getElementById('move-right-btn').addEventListener('click', () => { if(gameRunning) { playerMove(1); draw(); } });
        document.getElementById('rotate-btn').addEventListener('click', () => { if(gameRunning) { playerRotate(); draw(); } });
        document.getElementById('fast-down-btn').addEventListener('click', () => { if(gameRunning) { playerDrop(); draw(); } });

        // --- PWA & Offline Functionality ---
        function setupPWA() {
            // 1. Create and inject manifest link
            const manifest = {
                "name": "GAMERYT Tetris",
                "short_name": "Tetris",
                "start_url": ".",
                "display": "standalone",
                "background_color": "#111827",
                "theme_color": "#4f46e5",
                "description": "A classic Tetris game by GAMERYTDeveloper.",
                "icons": [{
                    "src": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iIzRmNDZlNSI+PHBhdGggZD0iTTkgM0gxNVY5SDIxVjE1SDE1VjIxSDlWMTVIM1Y5SDlWM1oiLz48L3N2Zz4=",
                    "sizes": "192x192",
                    "type": "image/svg+xml"
                }, {
                    "src": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iIzRmNDZlNSI+PHBhdGggZD0iTTkgM0gxNVY5SDIxVjE1SDE1VjIxSDlWMTVIM1Y5SDlWM1oiLz48L3N2Zz4=",
                    "sizes": "512x512",
                    "type": "image/svg+xml"
                }]
            };
            const manifestURL = `data:application/json;base64,${btoa(JSON.stringify(manifest))}`;
            document.querySelector('head').insertAdjacentHTML('beforeend', `<link rel="manifest" href="${manifestURL}">`);

            // 2. Register Service Worker
            if ('serviceWorker' in navigator) {
                const swCode = `
                    const CACHE_NAME = 'gameryt-tetris-v1';
                    const ASSETS_TO_CACHE = [ './' ];
                    self.addEventListener('install', (event) => {
                        event.waitUntil(
                            caches.open(CACHE_NAME).then((cache) => cache.addAll(ASSETS_TO_CACHE))
                        );
                    });
                    self.addEventListener('fetch', (event) => {
                        event.respondWith(
                            caches.match(event.request).then((response) => response || fetch(event.request))
                        );
                    });
                `;
                const swBlob = new Blob([swCode], { type: 'application/javascript' });
                const swURL = URL.createObjectURL(swBlob);
                navigator.serviceWorker.register(swURL)
                    .then(() => console.log('Service Worker Registered'))
                    .catch(err => console.error('Service Worker Registration Failed:', err));
            }

            // 3. Offline detection
            const offlineBanner = document.getElementById('offline-banner');
            const appContainer = document.getElementById('app');
            function updateOnlineStatus() {
                if (navigator.onLine) {
                    offlineBanner.classList.add('hidden');
                    appContainer.style.paddingTop = '0';
                } else {
                    offlineBanner.classList.remove('hidden');
                    appContainer.style.paddingTop = offlineBanner.offsetHeight + 'px';
                }
            }
            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);
            updateOnlineStatus();
        }

        // --- Initial Setup ---
        loadSettings();
        loadGameStats();
        loadCustomPieces();
        updateLanguage('en');
        renderBlockSelection();
        startGame();
        setupPWA();
        
        function animate() {
            if (gameRunning) draw();
            requestAnimationFrame(animate);
        }
        animate();
    });
    </script>
</body>
</html>
